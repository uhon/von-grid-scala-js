package vongrid

import org.denigma.threejs._
import vongrid.config.{ExtrudeSettings, HexGridConfig, SimpleTileGenConfig, TileGenConfig}

import scala.scalajs.js
import scala.scalajs.js.UndefOr
import scala.scalajs.js.annotation.JSName

/**
  * Created by uhon on 27/03/16.
  */
@js.native
@JSName("vg.HexGrid")
class HexGrid(config: HexGridConfig) extends js.Object {
  var `type` = vongrid.HEX
  var size = js.native  // only used for generated maps
  var cellSize: Float = js.native
  protected var cells: js.Dictionary[Cell] = js.native
  var numCells: Int = js.native
  var extrudeSettings: ExtrudeSettings = js.native
  var autogenerated = false
  var verts: js.Array[Vector3] = js.native
  var cellShape: Shape = js.native
  var cellGeo: Geometry = js.native
  var cellShapeGeo: ShapeGeometry = js.native
  var _cellWidth: Float = js.native
  var _cellLength: Float = js.native
  var _hashDelimiter: String = js.native

  // pre-computed permutations
  private val _directions: js.Array[Cell] = js.native
  var _diagonals: js.Array[Cell] = js.native

  // cached objects
  var _list: js.Array[Cell] = js.native
  var vec3: Vector3 = js.native
  var _cel: Cell = js.native
  var _conversionVec: Cell = js.native
  var _geoCache: js.Array[ExtrudeGeometry] = js.native

  var TWO_THIRDS = 2 / 3



  /*  ________________________________________________________________________
    High-level functions that the Board interfaces with (all grids implement)
  */

  // grid cell (Hex in cube coordinate space) to position in pixels/world
  def cellToPixel(cell: Cell): Vector3 = js.native
  def pixelToCell(pos: Vector3): Cell = js.native
  def getCellAt(pos: Vector3): js.UndefOr[Cell] = js.native
  @JSName("getNeighbours")
  def getNeighbors(cell: Cell, diagonal: Boolean): js.Array[Cell] = js.native
  @JSName("getNeighbours")
  def getNeighbors(cell: Cell, diagonal: Boolean, filter: js.Function1[Cell, Cell]): js.Array[Cell] = js.native
  def getRandomCell(): Cell = js.native
  def cellToHash(cell: Cell): String = js.native
  def distance(cellA: Cell, cellB: Cell): Float = js.native
  def clearPath() = js.native
  def traverse(callback: js.Function0[Cell]) = js.native
  def generateTile(cell: Cell, scale: Double, material: MeshPhongMaterial = null): Tile = js.native
  @JSName("generateTiles")
  def generateTiles(): js.Array[Tile] = js.native
  @JSName("generateTiles")
  def generateTiles(tileConfig: TileGenConfig): js.Array[Tile] = js.native
  @JSName("generateTilePoly")
  def generateTilePoly(): Mesh = js.native
  @JSName("generateTilePoly")
  def generateTilePoly(material: Material): Mesh = js.native

  // create a flat, hexagon-shaped grid
  @JSName("generate")
  def generate(): js.Any = js.native
  @JSName("generate")
  def generate(config: SimpleTileGenConfig): js.Any = js.native

  def generateOverlay(size: Float, overlayObj: Object3D, overlayMat: LineMaterial): js.Any = js.native

  def add(cell: Cell): UndefOr[Cell] = js.native

  def remove(cell: Cell): js.Any = js.native

  def dispose(): js.Any = js.native
                                                           // TODO: really?
  def load(url: String, callback: js.Function0[String], scope: js.Object) = js.native

  def fromJSON(json: js.Object): js.Any = js.native

  def toJSON(): js.Object = js.native

  def _createVertex(i: Int): Vector3 = js.native

  def _cubeRound(h: Cell): Cell = js.native
}
